{"categories":[{"title":"centos7","uri":"http://localhost:1313/categories/centos7/"},{"title":"DBN","uri":"http://localhost:1313/categories/dbn/"},{"title":"Docker","uri":"http://localhost:1313/categories/docker/"},{"title":"git","uri":"http://localhost:1313/categories/git/"},{"title":"github","uri":"http://localhost:1313/categories/github/"},{"title":"go","uri":"http://localhost:1313/categories/go/"},{"title":"Python Standard Library","uri":"http://localhost:1313/categories/python-standard-library/"},{"title":"pytorch","uri":"http://localhost:1313/categories/pytorch/"}],"posts":[{"content":"centos7 中常用的查询命令 ps 显示当前进程信息  ps -A 显示所有的进程信息  PID TTY TIME CMD\r1 ? 00:00:08 systemd\r2 ? 00:00:00 kthreadd\r4 ? 00:00:00 kworker/0:0H\r6 ? 00:00:00 ksoftirqd/0\r7 ? 00:00:00 migration/0\r8 ? 00:00:00 rcu_bh\r9 ? 00:00:25 rcu_sched\r10 ? 00:00:00 lru-add-drain\r11 ? 00:00:00 watchdog/0\r12 ? 00:00:01 watchdog/1\r13 ? 00:00:00 migration/1\r14 ? 00:00:00 ksoftirqd/1\r16 ? 00:00:00 kworker/1:0H\r......\r ps -aux 显示所有包含其他使用者的行程  USER PID %CPU %MEM VSZ RSS TTY STAT START TIME COMMAND\rroot 1 0.0 0.1 125696 4264 ? Ss 04:55 0:08 /usr/lib/systemd/systemd --switched-root --system --deserialize 22\rroot 2 0.0 0.0 0 0 ? S 04:55 0:00 [kthreadd]\rroot 4 0.0 0.0 0 0 ? S\u0026lt; 04:55 0:00 [kworker/0:0H]\rroot 6 0.0 0.0 0 0 ? S 04:55 0:00 [ksoftirqd/0]\rroot 7 0.0 0.0 0 0 ? S 04:55 0:00 [migration/0]\rroot 8 0.0 0.0 0 0 ? S 04:55 0:00 [rcu_bh]\rroot 9 0.0 0.0 0 0 ? S 04:55 0:25 [rcu_sched]\rroot 10 0.0 0.0 0 0 ? S\u0026lt; 04:55 0:00 [lru-add-drain]\r  ps -ef 显示所有进程信息，连同命令行\n  ps -u [用户名] 查询指定用户名的所有进程\n  netstat 查询网络信息 常用参数：\n-a (all)显示所有选项，默认不显示LISTEN相关\n-t (tcp)仅显示tcp相关选项\n-u (udp)仅显示udp相关选项\n-n 拒绝显示别名，能显示数字的全部转化成数字。\n-l 仅列出有在 Listen (监听) 的服务状态\n-p 显示建立相关链接的程序名\nnetstat 查询所有的网络状态 netstat -a\r 一般使用的话 # 查询相应的处于监听状态的tcp netstat -alnt # 查询指定的端口号\rnetstat -alnt | grep 8080\r# 加上 p 查询到相应的 进程\rnetstat -alntp | grep 8080\r ","id":0,"section":"posts","summary":"centos7 中常用的查询命令 ps 显示当前进程信息 ps -A 显示所有的进程信息 PID TTY TIME CMD 1 ? 00:00:08 systemd 2 ? 00:00:00 kthreadd 4 ? 00:00:00 kworker/0:0H 6 ? 00:00:00 ksoftirqd/0 7 ? 00:00:00 migration/0 8 ? 00:00:00 rcu_bh 9 ? 00:00:25 rcu_sched 10 ? 00:00:00 lru-add-drain 11 ? 00:00:00 watchdog/0 12","tags":["centos7"],"title":"centos7 中常用的查询命令","uri":"http://localhost:1313/2020/09/querycommand/","year":"2020"},{"content":"Centos7 安装redis 1、 检查是否有redis yum 源 若没有执行下一步，若有执行第三步\nyum search redis\ryum info redis\r 2、安装 epel 仓库 yum install -y epel-release  3、 安装redis 数据库 yum info redis\ryum install -y redis\r 4、 启动redis服务 systemctl start redis\rsystemctl enable redis # 设置开机启动\r 5、进入 redis 客户端 [admin@localhost ~]$ redis-cli\r127.0.0.1:6379\u0026gt;  ","id":1,"section":"posts","summary":"Centos7 安装redis 1、 检查是否有redis yum 源 若没有执行下一步，若有执行第三步 yum search redis yum info redis 2、安装 epel 仓库 yum install -y epel-release 3、 安装redis 数据库 yum info redis","tags":["centos7"],"title":"Centos7 安装redis","uri":"http://localhost:1313/2020/09/installredis/","year":"2020"},{"content":"Centos7 下traojan配置privoxy 下载trojan 首先去github下载 linux版本 https://github.com/trojan-gfw/trojan/releases/tag/v1.16.0\nwget https://github.com/trojan-gfw/trojan/releases/download/v1.16.0/trojan-1.16.0-linux-amd64.tar.xz tar xvf trojan-1.16.0-linux-amd64.tar.xz  将配置写在config.json下\ncd trojan // 写入配置 vi config.json // 后台运行trojan nohup ./trojan \u0026amp;  下载与配置privoxy 安装 wget https://download-ib01.fedoraproject.org/pub/epel/7/x86_64/Packages/p/privoxy-3.0.26-1.el7.x86_64.rpm rpm -Uvh privoxy-3.0.26-1.el7.x86_64.rpm  配置 vi /etc/privoxy/config  写入以下内容\nlisten-address 127.0.0.1:1081 toggle 0 show-on-task-bar 0 activity-animation 0 forward-socks5 / 127.0.0.1:1080 . hide-console  启动服务 先关闭selinux, 不然可能没法启用privoxy\n//1. 临时关闭 setenforce 0 // 2. 永久关闭 (需要reboot才能生效) vi /etc/selinux/config // 找到对应行，设置disabled SELINUX=disabled // 重新启动, 若设置永久关闭需要重新启动trojan reboot  启动代理\nsystemctl start privoxy.service  设置全局代理 export http_proxy=http://localhost:1081/ export https_proxy=http://localhost:1081/  ping [root@localhost Downloads]# ping google.com PING google.com (172.217.25.14) 56(84) bytes of data. 64 bytes from hkg07s24-in-f14.1e100.net (172.217.25.14): icmp_seq=1 ttl=116 time=23.2 ms 64 bytes from hkg07s24-in-f14.1e100.net (172.217.25.14): icmp_seq=2 ttl=116 time=23.6 ms 64 bytes from hkg07s24-in-f14.1e100.net (172.217.25.14): icmp_seq=3 ttl=116 time=23.6 ms 64 bytes from hkg07s24-in-f14.1e100.net (172.217.25.14): icmp_seq=4 ttl=116 time=23.9 ms 64 bytes from hkg07s24-in-f14.1e100.net (172.217.25.14): icmp_seq=5 ttl=116 time=23.3 ms  ","id":2,"section":"posts","summary":"Centos7 下traojan配置privoxy 下载trojan 首先去github下载 linux版本 https://github.com/trojan-gfw/trojan/releases/tag/v1.16.0 wget https://github.com/trojan-gfw/trojan/releases/download/v1.16.0/trojan-1.16.0-linux-amd64.tar.xz tar xvf trojan-1.16.0-linux-amd64.tar.xz 将配置写在config.json下 cd trojan //","tags":["centos7"],"title":"Privoxy","uri":"http://localhost:1313/2020/09/privoxy/","year":"2020"},{"content":"Beego安装 // 先安装bee 脚手架\rgo get github.com/beego/bee\r 在 go mod 模式下会安装失败，此时需要先关闭该模式再安装bee。\ngo env -w GO111MODULE=off\r 安装完成bee脚手架之后，会在gopath目录的bin文件下生成bee可执行文件，将 $GOPATH/bin 路径添加环境变量下。在命令行执行bee，出现以下表明安装bee脚手架成功了。\n","id":3,"section":"posts","summary":"","tags":["beego"],"title":"beego安装与配置","uri":"http://localhost:1313/2020/06/beegoinit/","year":"2020"},{"content":"golang实现不分配额外内存[]byte和string转换 普通的强转 一般在进行[]byte 和string之间进行转换时，通过进行强转实现。这样进行强转的话，都会在额外的拷贝，从而造成额外的内存分配。\nstr := \u0026quot;test\u0026quot;\r// 转换为[]byte\rbytes := []byte(str)\r// 转换为str\rstr1 := string(bytes)\r 优化后 // 通过底层数据转换\rpackage strbytesconv\rimport (\r\u0026quot;reflect\u0026quot;\r\u0026quot;unsafe\u0026quot;\r)\r// StringToBytes 实现string 转换成 []byte, 不用额外的内存分配\rfunc StringToBytes(str string) (bytes []byte) {\rss := *(*reflect.StringHeader)(unsafe.Pointer(\u0026amp;str))\rbs := (*reflect.SliceHeader)(unsafe.Pointer(\u0026amp;bytes))\rbs.Data = ss.Data\rbs.Len = ss.Len\rbs.Cap = ss.Len\rreturn bytes\r}\r// BytesToString 实现 []byte 转换成 string, 不需要额外的内存分配\rfunc BytesToString(bytes []byte) string {\rreturn *(*string)(unsafe.Pointer(\u0026amp;bytes))\r}\r  StringHeader 是go中string 在底层的定义  type StringHeader struct {\rData uintptr\rLen int\r}\r  SliceHeader 是go中切片 在底层的定义  type SliceHeader struct {\rData uintptr\rLen int\rCap int\r}\r 上诉的优化方法通过将unsafe.Pointer获取地址，实现 SliceHeader 和 SliceHeader 之间的转换。\n测试 准确率测试-通过 func Test_StringToBytes(t *testing.T) {\rtype args struct {\rstr string\r}\rtests := []struct {\rname string\rargs args\rwantBytes []byte\r}{\r// TODO: Add test cases.\r{\rname: \u0026quot;testStrToBytes\u0026quot;,\rargs: args{\rstr: \u0026quot;abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\u0026quot;,\r},\rwantBytes: []byte(\u0026quot;abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\u0026quot;),\r},\r}\rfor _, tt := range tests {\rt.Run(tt.name, func(t *testing.T) {\rgotBytes := StringToBytes(tt.args.str)\rif !reflect.DeepEqual(gotBytes, tt.wantBytes) {\rt.Errorf(\u0026quot;StringToBytes() = %v, want %v\u0026quot;, gotBytes, tt.wantBytes)\r}\rt.Logf(\u0026quot;gotBytes Pointer %p, tt.args.str Pointer %p\u0026quot;, \u0026amp;gotBytes, \u0026amp;tt.args.str)\r})\r}\r}\r func Test_BytesToString(t *testing.T) {\rtype args struct {\rbytes []byte\r}\rtests := []struct {\rname string\rargs args\rwant string\r}{\r// TODO: Add test cases.\r{\rname: \u0026quot;testBytesToStr\u0026quot;,\rargs: args{\rbytes: []byte(\u0026quot;abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\u0026quot;),\r},\rwant: \u0026quot;abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\u0026quot;,\r},\r}\rfor _, tt := range tests {\rt.Run(tt.name, func(t *testing.T) {\rgot := BytesToString(tt.args.bytes)\rif got != tt.want {\rt.Errorf(\u0026quot;BytesToString() = %v, want %v\u0026quot;, got, tt.want)\r}\rt.Logf(\u0026quot;gotStr Pointer %p, tt.args.bytes Pointer %p\u0026quot;, \u0026amp;got, \u0026amp;tt.args.bytes)\r})\r}\r}\r 基准测试 var testStr = \u0026quot;abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\u0026quot;\rvar testBytes = []byte(testStr)\rfunc getBytesToString(bytes []byte) string {\rreturn string(bytes)\r}\rfunc getStringToBytes(str string) []byte {\rreturn []byte(str)\r}\rfunc Benchmark_StringToBytes(b *testing.B) {\rfor i := 0; i \u0026lt; b.N; i++ {\rStringToBytes(testStr)\r}\r}\rfunc Benchmark_getStringToBytes(b *testing.B) {\rfor i := 0; i \u0026lt; b.N; i++ {\rgetStringToBytes(testStr)\r}\r}\rfunc Benchmark_BytesToString(b *testing.B) {\rfor i := 0; i \u0026lt; b.N; i++ {\rBytesToString(testBytes)\r}\r}\rfunc Benchmark_getBytesToString(b *testing.B) {\rfor i := 0; i \u0026lt; b.N; i++ {\rgetBytesToString(testBytes)\r}\r}\r 结果 执行：\rgo test -v -run=none -bench=. -benchmem=true\rBenchmark_StringToBytes-8 1000000000 0.477 ns/op 0 B/op 0 allocs/op\rBenchmark_getStringToBytes-8 20491503 58.0 ns/op 64 B/op 1 allocs/op\rBenchmark_BytesToString-8 1000000000 0.473 ns/op 0 B/op 0 allocs/op\rBenchmark_getBytesToString-8 22655529 49.1 ns/op 64 B/op 1 allocs/op\r 可以看出，有明显的速度提升\n","id":4,"section":"posts","summary":"golang实现不分配额外内存[]byte和string转换 普通的强转 一般在进行[]byte 和string之间进行转换时，通过进行强转实现。","tags":["go"],"title":"golang实现不分配额外内存[]byte和string转换","uri":"http://localhost:1313/2020/06/strbytesconv/","year":"2020"},{"content":"Goroutines和Channels 并发程序指同时进行多个任务的程序，随着硬件的发展，并发程序变得越来越重要。web服务器会一次处理成千上万的请求。平板电脑和手机app在渲染用户画面同时还会后台执行各种计算任务和网络请求。即使是传统的批处理问题-读取数据，计算，写输出-现在也会用并发来隐藏掉I/O的操作延迟以充分利用现代计算机设备的多个核心。计算机的性能每年都在以非线性的速度增长。\ngolang中并发程序可以用俩种手段来实现，本章讲解goroutine和channe，其支持“顺序通信进程”（communicating sequential processes）或被简称为CSP。CSP是一种现代的并发编程模型，在这种编程模型中值会在不同的运行实例（goroutine）中传递，尽管大多数情况下任然是被限制在单一实例中。\nGoroutine goroutine和线程 goroutine和操作系统的线程区别可以忽略不记，俩者的区别实际上只是一个量上的区别，但是量变会引起质变的道理同样适用于goroutine和线程。\n动态栈 每一个OS线程都有一个固定大小的内存块（一般会是2MB）来做栈，这个栈会用来存储当前正在被调用或挂起（指在调用其它函数时）的函数的内部变量。\n而每一个goroutine会以一个很小的栈开始其生命周期，一般只需要2KB，一个goroutine的栈和操作系统线程一样，会保存其活跃或挂起的函数调用的本地变量。\n但是和OS线程不太一样的是一个goroutine的栈大小并不是固定的，栈的大小会根据需要动态地伸缩。而goroutine栈的最大值有1GB，比传统的固定大小的线程栈要大得多，尽管一般情况下，大多goroutine都不需要这么大得栈。\ngoroutine调度 OS线程会被操作系统内核调度，每几毫秒，一个硬件计时器会中断处理器，这会调用一个叫做scheduler的内核函数，这个函数会挂起当前执行的线程并保存内存中它的寄存器内容，并检查线程列表并决定下一次哪个线程可以被运行，并从内存中恢复该线程的寄存器信息，然后恢复执行该线程的现场并开始执行线程。因为操作系统线程是被内核所调度，所以从一个线程恢复执行该线程的现场并开始执行线程。\n因为操作系统线程是被内核所调度，所以从一个线程向另一个“移动”需要完整的上下文切换，也就是说保存一个用户线程的状态到内存，恢复另一个线程到寄存器，然后更新调度器的数据结构。这几步操作很慢，因为其局限性很差需要几次内存访问，并且会增加运行的cpu周期。\nGo的运行时包含了其自己的调度器，这个调度器使用了一些技术手段，比如m：n调度，因为其会在n个操作系统线程上多工调度m个goroutine。Go调度器的工作和内核的调度是相似的，但是这个调度器只会关注单独Go程序中的goroutine。\n和操作系统的线程调度不同的是，go调度器并不是用一个硬件定时器而是被go语言”建筑“本身进行调度的。例如当一个goroutine调用了time.Sleep或者被channel调用或者mutex操作阻塞时，调度器会使其进入休眠并开始执行另一个goroutine直到时机到了再去唤醒第一goroutine。因为这种调度方式不需要进入内核的上下文，所以重新调度一个goroutine比调度一个线程代价要低得多。\n并发版本的hello world 使用 sync.mutex 实现 func main() {\rvar mu sync.mutex\rmu.Lock()\rgo func() {\rfmt.Println(\u0026quot;hello world\u0026quot;)\rmu.Unlock()\r}()\rmu.Lock()\r}\r 在第二次执行Lock() 锁时，由于锁已经被占用所以main函数会阻塞，此时main函数的阻塞会驱使goroutine继续，当goroutine执行完毕时，一个锁会打开，第二锁会继续锁住，main函数会继续执行。\n使用无缓冲通道channel 实现 使用互斥锁是比较低级的做法，现在使用无缓冲的管道实现。\nfunc main() {\rdone := make(chan int)\rgo func() {\rfmt.Println(\u0026quot;hello world\u0026quot;)\r\u0026lt;- done }\rdone \u0026lt;- 1\r}\r// 也调换位置实现\r 上面中，在最后一条语句向done发送一条1，由于done是无缓冲的，所以它会一直等待done接收才会向下执行。\n根据go语言内存模型规范，对于无缓冲Channel进行的接收，发生在对该Channel进行的发送完成之前，因此，后台线程 \u0026lt;-done 接收操作完成之后， main线程的 done \u0026lt;- 1 发送操作才可能完成(从而退出main, 退出程序), 而此时打印工作已经完成了。\n使用有缓存的通道 上面无缓冲的通道虽然可以正常同步，但是对管道的缓存大小敏感，如果管道有缓存的话，就无法保证main退出之前后台线程能正常打印了。\n更好的做法是管道的发送和接收方向调换一下，这样可以避免同步事件受管道缓存大小的影像。\nfunc main() {\rdone := make(chan int, 1)\rgo func() {\rfmt.Println(\u0026quot;hello world\u0026quot;)\rdone \u0026lt;- 1\r}\r\u0026lt;-done\r}\r 对于带缓冲的Channel，对于Channel 的第K个接收完成操作发生在第K+C个发送操作完成之前，其中C是Channel的缓存太小，虽然管道是带缓存的，main 线程接收完成是在后台线程发送开始但还未完成的时刻，此时打印工作也是已经完成的。\nN个缓存的通道 基于带缓存的管道，我们可以很容易将打印线程扩展到N个。下面的例子是开启10个后台线程分别打印\nfunc main() {\rdone := make(chan int, 10) // 开N个后台打印缓存\rfor i := 0; i \u0026lt; cap(done); i++ {\rgo func() {\rfmt.Println(\u0026quot;hello world\u0026quot;)\rdone \u0026lt;- 1\r}()\r}\r// 等待N 个后台线程完成\rfor i := 0; i \u0026lt; cap(done); i++ {\r\u0026lt;- done\r}\r}\r 使用 sync.WaitGroup 来实现 func main() {\rvar wg sync.WaitGroup\r// 开N个后台打印线程\rfor i := 0; i \u0026lt; 10; i++ {\rwg.Add(1)\rgo func() {\rfmt.Println(\u0026quot;hello world\u0026quot;)\rwg.Done()\r}()\r// 等待N个后台线程完成\rwg.Wait()\r}\r}\r 其中 wg.Add(1) 用于增加等待事件的个数，必须确保在后台线程启动之前启动，当后台线程完成打印工作之后，调用 wg.Done() 表示完成一个事件。main 函数的wg.Wait() 是等待全部的事件完成。\n","id":5,"section":"posts","summary":"Goroutines和Channels 并发程序指同时进行多个任务的程序，随着硬件的发展，并发程序变得越来越重要。web服务器会一次处理成千上","tags":["go"],"title":"Goroutines和Channels","uri":"http://localhost:1313/2020/06/goroutines_and_channels/","year":"2020"},{"content":"golang 数据结构之map 介绍 map是hash table数据结构，它支持快速的查找、增加和删除。\n定义和声明 map[keyType]ValueType\r 其中 keyType 必须是可比较的数据类型 (golang官网说明)，比如 布尔类型（bool）、数值类型（int, uint, float等)、string、指针（pointer）、通道（channel）、接口（interface）或者包含以上基础类型的 struct、arrays。 但是不支持 切片（slices)、map、函数（function）。\nvalueType 支持任何数据类型\n这样定义一个map，maps的值为nil，必须重新进行赋值才能够访问，若直接进行访问，会导致runtime panic。\nvar maps map[int]int\r 建议通过make定义一个map，这样在创建的时候make会分配和初始化一个hash map数据结构。\nmaps := make(map[int]int)\r map的使用 map支持存在与不存在的key值进行访问，若key值存在返回，相应的value；若不存在返回valueType的零值\nmaps := make(map[int]int)\rmaps[1] = 2\rmaps[3] = 4\rs1 := maps[1] // s1 == 1\rs2 := maps[2] //s1 == 2\r 支持判断是否当前key值存在\ns3, ok := maps[3] // s3 == 4, ok == true\rs4, ok := maps[4] // s4 == 0, ok == false\r 遍历map 通过range函数来遍历map，支持俩种遍历方式, 且都是无序遍历的。\n 只获取key值  for k := range maps {\r// 使用k\r}\r 获取kv值  for k, v := range maps {\r// 使用 k，v\r}\r 有序的遍历map  import \u0026quot;sort\u0026quot;\rvar maps map[int]int\rvar keys []int\rfor k := range maps {\rkeys = append(keys, k)\r}\rsort.Ints(keys)\rfor _, k := range keys {\rfmt.Println(\u0026quot;Key:\u0026quot;, k, \u0026quot;Value:\u0026quot;, maps[k])\r}\r ","id":6,"section":"posts","summary":"golang 数据结构之map 介绍 map是hash table数据结构，它支持快速的查找、增加和删除。 定义和声明 map[keyType]ValueType 其中 keyType 必须是可比较的数据类型 (golan","tags":["go"],"title":"map 介绍","uri":"http://localhost:1313/2020/06/map/","year":"2020"},{"content":"","id":7,"section":"posts","summary":"","tags":["docker"],"title":"Docker Overviews","uri":"http://localhost:1313/2020/03/test/","year":"2020"},{"content":"Docker-overview ","id":8,"section":"posts","summary":"Docker-overview ","tags":["docker"],"title":"Docker Overviews","uri":"http://localhost:1313/2020/03/docker-overviews/","year":"2020"},{"content":"受限波尔兹曼机(Restricted Boltzmann Machine, RBM) 受限波尔兹曼机(Restricted Boltzmann Machine, RBM)是一种可用随机神经网络来解释的概率图模型。它由Smolensky于1986年在波尔兹曼机的基础上提出的，所谓随机，是指这种网络中的神经元是随机神经元，其输出只有俩种状态（未激活/激活），一般用二进制的0和1来表示。而状态的具体取值则根据概率统计法则来决定。\n","id":9,"section":"posts","summary":"受限波尔兹曼机(Restricted Boltzmann Machine, RBM) 受限波尔兹曼机(Restricted Boltzmann Machine, RBM)是一种可用随机神经网络来解释的概率图模型。它由Sm","tags":["DBN"],"title":"RBM","uri":"http://localhost:1313/2020/02/rbm/","year":"2020"},{"content":"argparse 使用该库在终端操作中，可以在命令行中增加参数。\nargparse的使用 import argparse # 创建一个parser parser = argparse.ArgumentParser(description=\u0026quot;描述balabala\u0026quot;) # 增加参数,介于该参数众多只使用最常用的参数 \u0026quot;\u0026quot;\u0026quot; *args:str 参数名称 eg: '-c' '--config' default:str 默认值 type:{str, int, double, ...} 参数类型 help:str 参数解释 \u0026quot;\u0026quot;\u0026quot; parser.add_argument('-s', '--sum', default=\u0026quot;False\u0026quot;, type=str, help=\u0026quot;计算总和\u0026quot;) parser.add_argument('-m', '--multiply', default=\u0026quot;False\u0026quot;, type=str, help=\u0026quot;计算所有数向乘后的结果\u0026quot;) # 读取输入的参数 args = parser.parse_args() if args.sum == \u0026quot;True\u0026quot;: s = 0 for i in range(11): s += i print(f\u0026quot;1-10相加结果为{s}\u0026quot;) if args.multiply == \u0026quot;True\u0026quot;: m = 1 for i in range(1, 6): m *= i print(f\u0026quot;1-5相乘结果为{m}\u0026quot;)  # 在终端中输入以下得到 PS I:\\老师任务\\data create\\choice\u0026gt; python .\\test.py -s True 1-10相加结果为55 PS I:\\老师任务\\data create\\choice\u0026gt; python .\\test.py -s False -m True 1-5相乘结果为0 PS I:\\老师任务\\data create\\choice\u0026gt; python .\\test.py -s False -m True 1-5相乘结果为120 PS I:\\老师任务\\data create\\choice\u0026gt;  ","id":10,"section":"posts","summary":"argparse 使用该库在终端操作中，可以在命令行中增加参数。 argparse的使用 import argparse # 创建一个parser parser = argparse.ArgumentPar","tags":["psl"],"title":"Argparse","uri":"http://localhost:1313/2019/12/argparse/","year":"2019"},{"content":"mean方法 最近在学《动手学习深度学习》中批量归一化中对4维矩阵求归一化用到了mean方法，但是其中用到的参数dim让我看着一脸懵逼，经过一番挣扎，终于想清楚了！！！\ntorch.mean(input, dim, keepdim=False, out=None)-\u0026gt;Tensor ","id":11,"section":"posts","summary":"mean方法 最近在学《动手学习深度学习》中批量归一化中对4维矩阵求归一化用到了mean方法，但是其中用到的参数dim让我看着一脸懵逼，经过一","tags":["pytorch"],"title":"Pytorch_mean","uri":"http://localhost:1313/2019/11/pytorch_mean/","year":"2019"},{"content":"","id":12,"section":"posts","summary":"","tags":null,"title":"Asyncio","uri":"http://localhost:1313/2019/10/asyncio/","year":"2019"},{"content":"Functools 函数库用于高阶函数，作用于或返回其他函数的函数。\ncmp_to_key functools.cmp_to_key(func) 将原先的cmp函数转换成key功能的工具，用于sorted()， min()， max()， heapq.nlargeest()， heapq.nsmallest()， itertools.groupby()。\n# 使用cmp_to_key() 进行排序 from functools import cmp_to_key a = sorted([3, 4, 5, 1], key=cmp_to_key(lambda x,y: x-y)) print(a) # 使用cmp_to_key() 来进行对任意的俩个数组合成的最大值进行排序 nums = ['8', '555', '122', '10', '55', '7', '12'] ans_nums = sorted(nums, key=cmp_to_key(lambda x, y: int(x+y)-int(y+x))) print(ans_nums) # ['10', '12', '122', '555', '55', '7', '8'] ''' 1012 \u0026lt; 1210, 10122\u0026lt;12210, ... 12122 \u0026lt; 12212, 12555\u0026lt;55512, ... 122555 \u0026lt; 555122, 12255 \u0026lt; 55122, ... 557 \u0026lt; 755, 558 \u0026lt; 855, ... ''' #cmp_to_key() 的原型 def cmp_to_key(mycmp): 'Convert a cmp= function into a key= function' class K(object): def __init__(self, obj, *args): print('obj created with ',obj) self.obj = obj def __lt__(self, other): print('comparing less than ',self.obj) return mycmp(self.obj, other.obj) \u0026lt; 0 def __gt__(self, other): print('comparing greter than ',self.obj) return mycmp(self.obj, other.obj) \u0026gt; 0 def __eq__(self, other): print('comparing equal to ',self.obj) return mycmp(self.obj, other.obj) == 0 def __le__(self, other): print('comparing less than equal ',self.obj) return mycmp(self.obj, other.obj) \u0026lt;= 0 def __ge__(self, other): print('comparing greater than equal',self.obj) return mycmp(self.obj, other.obj) \u0026gt;= 0 def __ne__(self, other): print('comparing not equal ',self.obj) return mycmp(self.obj, other.obj) != 0 return K def mycmp(a, b): print(\u0026quot;In Mycmp for\u0026quot;, a, ' ', b) if a \u0026lt; b: return -1 elif a \u0026gt; b: return 1 elif a == b: return 0 print(sorted([3,4,2,5],key=cmp_to_key(mycmp))) ''' obj created with 3 obj created with 4 obj created with 2 obj created with 5 comparing less than 4 In Mycmp for 4 3 comparing less than 2 In Mycmp for 2 4 comparing less than 2 In Mycmp for 2 4 comparing less than 2 In Mycmp for 2 3 comparing less than 5 In Mycmp for 5 3 comparing less than 5 In Mycmp for 5 4 [2, 3, 4, 5] '''  lru_cache @functools.lru_cache(maxsize=128, typed=False) 装饰成具有缓存机制，空间最大可储存maxsize大小的函数。 lru表示最近最少使用 maxsize 初始值为128，若为None则无限缓存 typed 用来区分参数，比如fun(3) 与 fun(3.0)\n# 不使用@lru_cache来计算 import time def fib(n): print(\u0026quot;I'm processing {}\u0026quot;.format(n),end=\u0026quot; \u0026quot;) if n \u0026lt; 2: return n return fib(n-1) + fib(n-2) t1 = time.clock() a = [] for n in [5, 3]: a.append(fib(n)) print('\\n') t2 = time.clock() print(a) print(t2 - t1) ''' I'm processing 5 I'm processing 4 I'm processing 3 I'm processing 2 I'm processing 1 I'm processing 0 I'm processing 1 I'm processing 2 I'm processing 1 I'm processing 0 I'm processing 3 I'm processing 2 I'm processing 1 I'm processing 0 I'm processing 1 I'm processing 3 I'm processing 2 I'm processing 1 I'm processing 0 I'm processing 1 [5, 2] 0.000754200000073979 ''' # 使用@lru_cache来计算 from functools import lru_cache import time @lru_cache(maxsize=None) def fib(n): print(\u0026quot;I'm processing {}\u0026quot;.format(n),end=\u0026quot; \u0026quot;) if n \u0026lt; 2: return n return fib(n-1) + fib(n-2) t1 = time.clock() a = [] for n in [5, 3]: a.append(fib(n)) print('\\n') t2 = time.clock() print(a) print(t2 - t1) print(fib.cache_info()) ''' I'm processing 5 I'm processing 4 I'm processing 3 I'm processing 2 I'm processing 1 I'm processing 0 [5, 2] 0.0006648000003224297 CacheInfo(hits=4, misses=6, maxsize=None, currsize=6) '''  从上可以看出，之前执行过的函数都被保存在cache中，省去了很多计算\n# 计算时间性能 # 不使用@lru_cache 计算 import time def fib(n): #print(\u0026quot;I'm processing {}\u0026quot;.format(n),end=\u0026quot; \u0026quot;) if n \u0026lt; 2: return n return fib(n-1) + fib(n-2) t1 = time.clock() a = [fib(n) for n in range(40)] t2 = time.clock() print(a) print(t2 - t1,\u0026quot; s\u0026quot;) ''' [0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610, 987, 1597, 2584, 4181, 6765, 10946, 17711, 28657, 46368, 75025, 121393, 196418, 317811, 514229, 832040, 1346269, 2178309, 3524578, 5702887, 9227465, 14930352, 24157817, 39088169, 63245986] 54.68690629999992 s ''' # 使用@lru_cache计算 from functools import lru_cache import time @lru_cache(maxsize=None) def fib(n): #print(\u0026quot;I'm processing {}\u0026quot;.format(n),end=\u0026quot; \u0026quot;) if n \u0026lt; 2: return n return fib(n-1) + fib(n-2) t1 = time.clock() a = [fib(n) for n in range(40)] t2 = time.clock() print(a) print(t2 - t1, \u0026quot; s\u0026quot;) print(fib.cache_info()) ''' [0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610, 987, 1597, 2584, 4181, 6765, 10946, 17711, 28657, 46368, 75025, 121393, 196418, 317811, 514229, 832040, 1346269, 2178309, 3524578, 5702887, 9227465, 14930352, 24157817, 39088169, 63245986] 9.619999946153257e-05 s CacheInfo(hits=76, misses=40, maxsize=None, currsize=40) '''  从上得到，不使用@lru_cache 时间为54.6s 使用时仅仅为0.00009s\n使用cache_info() 来查看缓存信息 使用cache_clear() 来清除缓存\npartial functools.partial(func, *args, **keywords) 返回一个具有func功能，并且带有args和keywords参数的partial object\n# 将一个数字字符串转化为2进制数 from functools import partial basetwo = partial(int, base=2) basetwo.__doc__ = 'Convert base 2 string to an int' basetwo('10010') # 上面式子等价于 int('10010', base=2) # 18 # 假设你项以某个点为基点，根据点和基点之间的距离来排序所有的这些点。 import math from functools import partial def distance(p1, p2): x1, y1 = p1 x2, y2 = p2 return math.hypot(x2-x1, y2-y1) points = [ (1, 2), (3, 4), (5, 6), (7, 8) ] # 以（4，3）为基点 ans = sorted(points, key=partial(distance, (4,3))) print(ans) # [(3, 4), (1, 2), (5, 6), (7, 8)]  ","id":13,"section":"posts","summary":"Functools 函数库用于高阶函数，作用于或返回其他函数的函数。 cmp_to_key functools.cmp_to_key(func) 将原先的cmp函数转换成key功能的工具，用于sorted()， min()， max()","tags":["psl","functions"],"title":"Functools","uri":"http://localhost:1313/2019/10/functools/","year":"2019"},{"content":"Collections 主要提供特别功能的容器来代替内置模块中dict/list/set/tuple\ncollections模块主要函数  namedtuple deque ChainMap Counter OrderedDIct defaultdict UserDict UserDict UserString  namedtuple 创建一个命名字段的元组工厂函数\n 表达式：collections.namedtuple(typename, *field_names, verbose=False, rename=False, module=None) typename表示名称，其值会传给__repr__ 函数，当需要打印时，会显示。 *field_names定义的名称字段集合，在实例化的数中，可通过intance.filed打印其值 verbose若为True,这个类在建立的时候会将其打印出来， rename若为True,无效的名称字段会将其转化为正常字段。 module若定义了，会自动给字段上名称  返回一个含有类型名称的新元组子类\n# Basic example from collections import namedtuple Point = namedtuple('Point', ['x', 'y']) p = Point(11, 22) a = p[0] + p[1] b = p.x + p.y # 通过fieldname直接调用值 print(a, ' ', b) # output: 33 33     classmethod somenamedtuple._make(iterable)\n  该方法会从iterable中直接传入值\n  from collections import namedtuple Point = namedtuple('Point', ['x, y']) t = [11, 22] a = Point._make(t) print(a) # output：Point(x=11, y=22)     somenamedtuple._asdict()\n  返回一个 OrderDict对象\n     somenamedtuple._replace(**kwarts)\n  将传入键值对的值与对应的名称字段的值替换，返回一个新的实例\n  ... p = Point(11, 22) p._replace(x=33) # p = Point(x=33, y=22)     somenamedtuple._fileds\n  返回字段名称\n    namedtuple可以用来做子类  from collections import namedtuple class Point(namedtuple('Point', ['x', 'y'])): # 通过—__slots__ 继承父类 namedtuple('Point', ['x', 'y'])(注意这是一个类)的__slots__属性，从而继承属性 x, y __slots__ = () @property def hypot(self): return (self.x ** 2 + self.y ** 2) ** 0.5 def __str__(self): return \u0026quot;Point: x=%6.3f y=%6.3f hypot=%6.3f\u0026quot; % (self.x, self.y, self.hypot) print(Point(3, 4)) print(Point(14, 5/7)) # output: # Point: x= 3.000 y= 4.000 hypot= 5.000 # Point: x=14.000 y= 0.714 hypot=14.018  deque deque 是队列和栈合并。\n class collections.deque([iterable[, maxlen]]) 将传入参数iterable中的值从左到右进入到deque中，若iterable为空，则deque为空   支持的方法  append(x) 将x插入deque的右边 appendleft(x) 将x插入deque的左边 clear() 将deque中所有元素清除 copy() 创建一个浅复制的deque count() 计算deque中所有元素的数量 extend(iterable)　将集合插入到deque的右边 extendleft(iterable) 将集合插入到deque的左边 index(x, start, stop) 返回x在deque中索引位置。若传入start和stop参数则对该区间内进行搜索 insert(i, x) 在deque索引位置i插入值x pop() 从最右边取出一个值，若没有元素，返回IndexError popleft() 从最左边取出一个值，若没有元素，返回IndexError remove(value) 清除第一个发现的值。若没有发现返回ValueError reverse() 返回反转后的deque rotate(n=1) 将deque向右移动n个元素，若n\u0026lt;0 则向左移动n个元素 maxlen() 返回容纳最大尺寸   Counter Counter用来快速和方便计算\n# 使用counter来快速统计每个单词的数量 from collections import Counter names = ['red', 'blue', 'red', 'green', 'blue', 'blue'] cnt = Counter(names) print(cnt) # outut: Counter({'blue': 3, 'red': 2, 'green': 1})  支持的方法  elements() 返回所有元素包括重复项的迭代器  ... print(sorted(cnt.elements())) # output: ['blue', 'blue', 'blue', 'green', 'red', 'red']   most_common(n) 返回一个包含每个键值对（转化成元组）前n组列表。  ... print(cnt.most_common(2)) # output: [('blue', 3), ('red', 2)]   支持加减运算  from collections import Counter c = Counter(a=1, b=2, c=3, d=4) d = Counter(a=0, b=1, c=2, d=3) print(c+d) print(c-d) print(c\u0026amp;d) print(c|d) # output: Counter({'d': 7, 'c': 5, 'b': 3, 'a': 1}) # Counter({'a': 1, 'b': 1, 'c': 1, 'd': 1}) # Counter({'d': 3, 'c': 2, 'b': 1}) # Counter({'d': 4, 'c': 3, 'b': 2, 'a': 1})   update(iterable) 增加iterable中的内容  from collections import Counter c = Counter(a=1, b=2, c=3, d=4) col = ['red', 'blue', 'red', 'green', 'blue', 'blue'] print(c) c.update(col) print(c) # Counter({'d': 4, 'c': 3, 'b': 2, 'a': 1}) # Counter({'d': 4, 'c': 3, 'blue': 3, 'b': 2, 'red': 2, 'a': 1, 'green': 1})  orderDict class collections.OrderDict([item]) 返回一个字典的子类，并且支持字典的方法。\n  popitem(last=True): 若last是True则采取后进先出的方法弹出一对键值对，若last是False则采取先进先出的方法弹出一对键值对\n  move_to_end(key, last=True): 若last=True将该键移至最右方，若last=False将该键移至最左方\n  OrderedDIct example\n  from collections import OrderedDict d = {'banana': 3, 'apple': 4, 'pear': 1, 'orange': 2} s = OrderedDict(sorted(d.items(),key=lambda x:x[0])) print(s) s1 = OrderedDict(sorted(d.items(),key=lambda x:x[1])) print(s1) s2 = OrderedDict(sorted(d.items(),key=lambda x:len(x[0]))) print(s2) # OrderedDict([('apple', 4), ('banana', 3), ('orange', 2), ('pear', 1)]) # OrderedDict([('pear', 1), ('orange', 2), ('banana', 3), ('apple', 4)]) # OrderedDict([('pear', 1), ('apple', 4), ('banana', 3), ('orange', 2)])  defaultdict class collecitons.defaultdict([default_factory]):default_factory可以为list，tuple 等序列，返回一个类字典对象\nfrom collections import defaultdict s = [('yellow', 1), ('blue', 2), ('yellow', 3), ('blue', 4), ('red', 1)] l = defaultdict(list) se = defaultdict(set) for k,v in s: l[k].append(v) se[k].add(v) print(l) print(se) # defaultdict(\u0026lt;class 'list'\u0026gt;, {'yellow': [1, 3], 'blue': [2, 4], 'red': [1]}) # defaultdict(\u0026lt;class 'set'\u0026gt;, {'yellow': {1, 3}, 'blue': {2, 4}, 'red': {1}})  ","id":14,"section":"posts","summary":"Collections 主要提供特别功能的容器来代替内置模块中dict/list/set/tuple collections模块主要函数 namedtuple deque ChainMap Counter OrderedDIct defaultdict UserDict UserDict UserString namedtuple 创建一个","tags":["psl","Collections"],"title":"Collections","uri":"http://localhost:1313/2019/10/collections/","year":"2019"},{"content":"iterator and generator iterator 概述 迭代器：迭代器是访问元素的一种方式，迭代器对象从集合的第一个元素开始访问，直到所有的元素被访问完结束。一般的序列（字符串/列表/元组）·非序列（字典/文件）·自定义类（使用iter()函数）创建iterator。\n内置函数iter(object, sentine) 返回一个iterator对象，根据第二个参数的有无，该函数有俩种使用方式：\n 当没有第二个参数的时候，object 必须是遵循 itertor protocol （含有 __iter__ 方法），或者支持 sequence protocol (含有 __getitem__ 方法)  # 将一个列表迭代化 a=list(range(9)) for i in iter(a): print(i, end=' ') # output: 0 1 2 3 4 5 6 7 8   在类fun中建立了__iter__,__next__ 函数。使fun可以迭代化  ## constructed __iter__() method class fun(): def __iter__(self): self.a = 1 return self def __next__(self): x = self.a self.a += 1 return x # 获得一个迭代器 b = iter(fun()) for i in range(20): # 使用next来进行驱动迭代器 print(next(b), end=' ')} # output：1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20   在自定义容器对象中，里面包含有列表/元组/其他可迭代对象。使用__iter__方法进行迭代。  class Node(): def __init__(self, value): self._value = value self._children = [] def __repr__(self): return 'Node({})'.format(self._value) def add_child(self, node): self._children.append(node) def __iter__(self): return iter(self._children) root = Node(0) child1 = Node(1) child2 = Node(2) root.add_child(child1) root.add_child(child2) for ch in root: print(ch) print(root) # Node(1) # Node(2) # Node(0)   在func()建立__getitem__函数，使func()可迭代化  # constructed __getitem__() method class func(): a = 0 def __getitem__(self,item): self.a += 2 return self.a c = iter(func()) for i in range(20): print(next(c), end=' ') # output: 2 4 6 8 10 12 14 16 18 20 22 24 26 28 30 32 34 36 38 40   当含有第二个参数的时候，object 必须是一个可调用的函数。且当返回值等于 sentine 时，会 raise StopIteration ,若不等则会返回该值。  class fun(): def __init__(self, _start, _end): self.start = _start self.end = _end def callfun(self): if self.start \u0026lt; self.end: self.start += 1 else: raise StopIteration return self.start d = iter(fun(0,4).callfun,6) for i in d: print(i, end=' ') # output: 1 2 3 4 d = iter(fun(0,6).callfun,5) for i in d: print(i, end=' ') # output: 1 2 3 4  反向迭代 反方向迭代一个序列，使用内置函数__reversed()__ ,与__sorted()__ 返回一个列表不同，__reversed()__ 返回一个迭代器。\na = list(range(10)) for x in reversed(a): print(x, end=\u0026quot; \u0026quot;) # output: 9 8 7 6 5 4 3 2 1 0   在自定义类上若想反向迭代，则需要实现__reversed__() 方法来实现反向迭代。  class Countnum(): def __init__(self, start): self._start = start def __iter__(self) n = 0 while n \u0026lt;= self._start: yield n n += 1 def __reversed__(self): n = self._start while n \u0026gt; 0: yield n n -= 1 for x in Countnum(20): print(x,end=\u0026quot; \u0026quot;) print() for x in reversed(Countnum(20)): print(x,end=\u0026quot; \u0026quot;) # output: # 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 # 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30  generator 生成器和迭代器都是引入的新概念，生成器是一种使用普通函数语法定义的迭代器，使用yield来创建生成器。\n使用生成器创建迭代器 生成器创建起来与函数一样简单。\nnested = [[1, 2],[3, 4],[5]] def flatten(nested): for sublist in nested: for element in sublist: yield element for num in flatten(nested): print(num, end=' ') # output: 1 2 3 4 5 # 创建一个类range的生成器 def frange(start, stop, increment=1): x = start while x \u0026lt; stop: yield x x += increment b = list(frange(1,4)) # b = [1, 2, 3]  生成器yield from yield只能够产生基本类型的变量，yield from用来返回一个容器/其他迭代器\nclass Node: def __init__(self,value): self._value = value self._children = [] def __repr__(self): return \u0026quot;Node({})\u0026quot;.format(self.value) def add_child(self,node): self._children.append(node) def __iter__(self): return self def depth_iter(self): yield self for c in self: yield c.depth_iter() root = Node(0) child1 = Node(1) child2 = Node(2) root.add_child(child1) root.add_child(child2) child1.add_child(Node(3)) child1.add_child(Node(4)) child2.add_child(Node(5)) for ch in root: print(ch, end=\u0026quot; \u0026quot;) # output: Node(0) Node(1) Node(3) Node(4) Node(2) Node(5)  生成器的方法  方法send：外部值可访问生成器的方法send，接受一个参数。  def repeater(value): while(True): new = yield value if new is not None: print('new just chaanged:{}'.format(new)) a = repeater(5) print(next(a)) print(a.send(\u0026quot;I'm a new\u0026quot;)) # 5 # new just chaanged:I'm a new # 5   方法next: 生成下一个值，若没有抛出StopIteration异常。 方法throw: 用于在生成器中（yield表达式处）引发异常，调用时可提供一个异常类型/一个可选值和一个traceback对象。 方法close: 用于停止生成器，调用时无需提供任何参数  生成器和迭代器的使用  使用for表达式：  # 返回一个列表 s = [x*x for x in range(10)] # 返回一个生成器 a = (x+2 for x in range(10)) # 结合三元目表达式 d = [item if item\u0026gt;0 else item*2 for item in range(10)]   带有外部状态的生成器函数 通过给自定义类添加属性，将属性暴露给外部函数来调用。  portfolio = [ {'name': 'IBM', 'shares': 100, 'price': 91.1}, {'name': 'AAPL', 'shares': 50, 'price': 543.22}, {'name': 'FB', 'shares': 200, 'price': 21.09}, {'name': 'HPQ', 'shares': 35, 'price': 31.75}, {'name': 'YHOO', 'shares': 45, 'price': 16.35}, {'name': 'ACME', 'shares': 75, 'price': 115.65} ] from heapq class countM(): def __init__(self, port): self.port = port self.maxProcess = heapq.nlargest(3, self.port, key=lambda X: x['price']*x['shares']) def __iter__(self): for x in self.port: yield x p = countM(portfolio) print(p.maxProcess) #调用属性 for mess in p: print(mess) #[{'name': 'AAPL', 'shares': 50, 'price': 543.22}, {'name': 'IBM', 'shares': 100, 'price': 91.1}, {'name': 'ACME', 'shares': 75, 'price': 115.65}] #{'name': 'IBM', 'shares': 100, 'price': 91.1} #{'name': 'AAPL', 'shares': 50, 'price': 543.22} #{'name': 'FB', 'shares': 200, 'price': 21.09} #{'name': 'HPQ', 'shares': 35, 'price': 31.75} #{'name': 'YHOO', 'shares': 45, 'price': 16.35} #{'name': 'ACME', 'shares': 75, 'price': 115.65}   迭代器切片 若你想得到一个迭代器切片，但是标准切片操作不能做到  # 使用itertools.islice() def count(n): while True: yield n n += 1 c = count(0) import itertools for x in itertools.islice(c, 10, 20): print(x, end=\u0026quot; \u0026quot;) # output: 10 11 12 13 14 15 16 17 18 19   序列上索引值迭代 你想在迭代一个序列的同时跟踪正在处理的元素序列，使用enumerate(itertor, start=0)  li = list(range(10)) for idx, value in enumerate(li, start=1): print(idx,value,sep=':',end=\u0026quot;, \u0026quot;) # output: 1:0, 2:1, 3:2, 4:3, 5:4, 6:5, 7:6, 8:7, 9:8, 10:9   同时迭代多个序列，使用zip()和itertools.zip_longest()  x = list(range(10)) y = list(range(0, 20, 2)) for i, y in zip(x, y): print(i, y, sep=\u0026quot;,\u0026quot;, end=\u0026quot; \u0026quot;) # output: 0,0 1,2 2,4 3,6 4,8 5,10 6,12 7,14 8,16 9,18 # 当序列长度不同时 使用zip() 截至到短序列的最后一个数。 x = [1, 2, 3, 4, 5, 6] y = [\u0026quot;a\u0026quot;, \u0026quot;b\u0026quot;, \u0026quot;c\u0026quot;, \u0026quot;d\u0026quot;] for i, j in zip(x,y): print(i, j,sep=\u0026quot;:\u0026quot;,end=\u0026quot; \u0026quot;) # output: 1:a 2:b 3:c 4:d # 使用itertools.zip_longest(*itertor, fillvalue=None)会对短序列进行填充 from itertools import zip_longest x = [1, 2, 3, 4, 5, 6] y = [\u0026quot;a\u0026quot;, \u0026quot;b\u0026quot;, \u0026quot;c\u0026quot;, \u0026quot;d\u0026quot;] for i, j in zip_longest(x,y,fillvalue=1): print(i, j,sep=\u0026quot;:\u0026quot;,end=\u0026quot; \u0026quot;) # output: 1:a 2:b 3:c 4:d 5:1 6:1   展开嵌套的序列 将一个多层嵌套的序列展开成一个单层列表，使用yield from语句  from collections import Iterable def flatten(items, ignore_types=(str, bytes)): for x in items: if isintance(x, Iterable) and not isintance(x, ignore_types): yield from flatten(x) else: yield x items = [1, 2, 3, [4, 5, [6 , 7, 8], 9], 10] for x in flatten(items): print(x,end=\u0026quot; \u0026quot;) # output: 1 2 3 4 5 6 7 8 9 10 items = ['Dave', 'Paula', ['Thomas', 'Lewis']] for x in flatten(items): print(x,end=\u0026quot; \u0026quot;) # output: Dave Paula Thomas Lewis  end 参考  python3-cookbook python标准库  ","id":15,"section":"posts","summary":"iterator and generator iterator 概述 迭代器：迭代器是访问元素的一种方式，迭代器对象从集合的第一个元素开始访问，直到所有的元素被访问完结束。一般的序列（字符串/列表/","tags":["psl","itertor and generator"],"title":"迭代器与生成器","uri":"http://localhost:1313/2019/10/%E8%BF%AD%E4%BB%A3%E5%99%A8%E4%B8%8E%E7%94%9F%E6%88%90%E5%99%A8/","year":"2019"},{"content":"Git 基本操作 查看工作状态和历史提交 进行仓库的初始化以及创建 git init 将文件添加到暂存区 git add 上传提交的名字 git commit -m \u0026quot;....\u0026quot; 查看状态 git status 将修改的文件从 暂存区中恢复 git checkout -- \\\u0026lt;file\u0026gt; 查看历史提交记录 git log 再次提交git  ","id":16,"section":"posts","summary":"Git 基本操作 查看工作状态和历史提交 进行仓库的初始化以及创建 git init 将文件添加到暂存区 git add 上传提交的名字 git commit -m \u0026quot;....\u0026quot; 查看状态 git status 将修改的文件从 暂存区中恢","tags":["git","github"],"title":"Git","uri":"http://localhost:1313/2019/10/git/","year":"2019"},{"content":"golang中sort.Sort方法的使用 ","id":17,"section":"posts","summary":"golang中sort.Sort方法的使用","tags":null,"title":"","uri":"http://localhost:1313/1/01/sort/","year":"0001"}],"tags":[{"title":"beego","uri":"http://localhost:1313/tags/beego/"},{"title":"centos7","uri":"http://localhost:1313/tags/centos7/"},{"title":"Collections","uri":"http://localhost:1313/tags/collections/"},{"title":"DBN","uri":"http://localhost:1313/tags/dbn/"},{"title":"docker","uri":"http://localhost:1313/tags/docker/"},{"title":"functions","uri":"http://localhost:1313/tags/functions/"},{"title":"git","uri":"http://localhost:1313/tags/git/"},{"title":"github","uri":"http://localhost:1313/tags/github/"},{"title":"go","uri":"http://localhost:1313/tags/go/"},{"title":"itertor and generator","uri":"http://localhost:1313/tags/itertor-and-generator/"},{"title":"psl","uri":"http://localhost:1313/tags/psl/"},{"title":"pytorch","uri":"http://localhost:1313/tags/pytorch/"}]}