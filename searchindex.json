{"categories":[{"title":"centos7","uri":"https://nattygui.github.io/categories/centos7/"},{"title":"git","uri":"https://nattygui.github.io/categories/git/"},{"title":"github","uri":"https://nattygui.github.io/categories/github/"},{"title":"go","uri":"https://nattygui.github.io/categories/go/"}],"posts":[{"content":"为什么使用反射 有时候我们需要编写一个函数能够处理一类并不满足普通公共接口类型的值，也有可能是因为它们并没有确定的表示方式，或者是在我们设计该函数的时候这些类型可能还不存在等等\n比如如下实现一个打印含有String() 方法的自定义类型和基本数据类型比如int、bool等。通过类型推断加上switch case分支进行判断。\nfunc Sprint(x interface{}) string { type stringer interface { String() string } switch x := x.(type) { case stringer: return x.String() case string: return x case int: return strconv.Itoa(x) case bool: if x { return \u0026quot;true\u0026quot; } return \u0026quot;false\u0026quot; default: return \u0026quot;unknown\u0026quot; } }  写下如下的测试函数，输出结果\ntype Call struct { content string } func (c *Call) String() string { return c.content } func TestSprint(t *testing.T) { call := Call{content: \u0026quot;This is call struct\u0026quot;} t.Log(Sprint(\u0026amp;call)) num := 4 t.Log(Sprint(num)) bl := true t.Log(Sprint(bl)) str := \u0026quot;a string\u0026quot; t.Log(Sprint(str)) s := struct{}{} t.Log(Sprint(s)) }  [admin@localhost whyUseReflect]$ go test -v === RUN TestSprint sprint_test.go:39: This is call struct sprint_test.go:42: 4 sprint_test.go:45: true sprint_test.go:48: a string sprint_test.go:51: unknown --- PASS: TestSprint (0.00s)  我们可以无限的添加类型，对每个类型进行添加，输出相应的结果，但是这些类型是无穷的，而且当对自定义类型的某个变量进行检查的时候，需要添加这个变量的定义。且当出现自定义类型本身进行嵌套的时候，会陷入死循环，如下所示：\ntype repeatCall struct { name string call *repeatCall }  此时，就需要引用反射了。\n","id":0,"section":"posts","summary":"为什么使用反射 有时候我们需要编写一个函数能够处理一类并不满足普通公共接口类型的值，也有可能是因为它们并没有确定的表示方式，或者是在我们设计该","tags":["reflect","go"],"title":"reflect","uri":"https://nattygui.github.io/2020/10/reflect/","year":"2020"},{"content":"reflect.Type 和 reflect.Value 反射是由reflect包提供支持，它定义了俩个重要的类型，Type和Value。\n一个Type表示一个Go类型，它是一个接口。reflect.Type 可以表示任意类型。\n一个Value表示一个Go值，reflect.Value 可以持有一个任意类型的值，\nreflect.Type 函数reflect.TypeOf 接受任意的interface{} 类型，并返回对应动态类型的reflect.Type:\nt := reflect.TypeOf(3) // 返回一个reflect.Type fmt.Println(t.String()) fmt.Println(t)  reflect.Type 是满足fmt.Stringer 接口的，比如以下打印类型，就是通过将值通过relfect.TypeOf 的结果输出的\nfmt.Printf(\u0026quot;%T\\n\u0026quot;, 3) // \u0026quot;int\u0026quot;  reflect.Value 函数reflect.ValueOf 接受任意的interface{} 类型，并返回对应动态类型的reflect.Value 和 reflect.TypeOf类似，reflect.ValueOf 返回的结果也是对于具体的类型，但是reflect.Value 也可以持有一个接口值。\n和reflect.Type 类似，reflect.Value 也满足fmt.Stringer接口，但是除非Value 持有的是字符串,否则String 只是返回具体的类型。\nv := reflect.ValueOf(3) // 返回一个 reflect.Value fmt.Println(v) // \u0026quot;3\u0026quot; fmt.Printf(\u0026quot;%v\\n\u0026quot;, v) // \u0026quot;3\u0026quot; fmt.Println(v.String())  调用Value 的Type 方法将返回具体类型所对应的 reflect.Type:\nt := v.Type() // 返回一个reflect.Type fmt.Println(t.String()) // \u0026quot;int\u0026quot;  逆操作是调用reflect.ValueOf 对应的 reflect.Value.Interface 方法，它返回一个 interface{} 类型表示reflect.Value 对应的具体值：\nv := reflect.ValueOf(3) // 得到一个reflect.Value x := v.Interface() // 转换为interface{} i := x.(int) // 转为int fmt.Printf(\u0026quot;%d\\n\u0026quot;, i) // 3  一个reflect.Value 和interface 都能够存储任意的值，所不同的是，一个空的接口隐藏了值对应的表示方式和所有的公开的方法，因此只有我们知道具体的动态类型才能使用类型断言来访问内部的值。\n但reflect.Value 可以通过Kind 方法获取对应的类型，然后再进行类型选择，且kinds 的类型是有限的\n以下的kinds 所有类型：\n   kind     Bool   String   Int Int8\u0026hellip; Uint Uint8\u0026hellip;   Chan   Func   Ptr   Slice   Map   Array   Struct   Interface   Invalid   \u0026hellip;    实现打印值：\npackage format import ( \u0026quot;fmt\u0026quot; \u0026quot;reflect\u0026quot; \u0026quot;strconv\u0026quot; \u0026quot;testing\u0026quot; \u0026quot;time\u0026quot; ) func Any(value interface{}) string { return formatAtom(reflect.ValueOf(value)) } func formatAtom(v reflect.Value) string { switch v.Kind() { case reflect.Invalid: return \u0026quot;invalid\u0026quot; case reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64: return strconv.FormatInt(v.Int(), 10) case reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64, reflect.Uintptr: return strconv.FormatUint(v.Uint(), 10) case reflect.Bool: return strconv.FormatBool(v.Bool()) case reflect.String: return v.String() case reflect.Chan, reflect.Func, reflect.Ptr, reflect.Slice, reflect.Map: return v.Type().String() + \u0026quot; 0x\u0026quot; + strconv.FormatUint(uint64(v.Pointer()), 16) default: // reflect.Array, reflect.Struct, reflect.Interface return v.Type().String() + \u0026quot; value\u0026quot; } } func Test_formatAtom(t *testing.T) { var x int64 = 1 var d time.Duration = 1 * time.Nanosecond fmt.Println(Any(x)) fmt.Println(Any(d)) fmt.Println(Any([]int64{x})) fmt.Println(Any([]time.Duration{d})) }  实现一个结构体解析为json格式 传入reflect.Value 打印相应的值\n  通过v.Kind() 方法，获取当前value 类型 对每个类型进行分析， 根据对应的类型打印值\n  对于Slice 和Array 俩者的逻辑是一样的，Len 方法返回Slice 或Array 值中的元素个数， Index(i) 活动索引i对应的元素，返回的也是一个reflect.Value 类型的值；\n  Struct： NumField 方法报告结构体中成员的数量，Field(i)以reflect.Value 类型返回第i个成员的值。\n  Map: MapKeys 方法返回一个reflect.Value类型的slice, 每一个都对应map的key。 遍历map 的顺序也是随机的。MapIndex(key) 返回map 中key 对应的value。\n  import ( \u0026quot;encoding/json\u0026quot; \u0026quot;bytes\u0026quot; \u0026quot;fmt\u0026quot; \u0026quot;reflect\u0026quot; \u0026quot;testing\u0026quot; ) // Marshal jsonmarshal 将一个类型解析为json格式 func Marshal(x interface{}) ([]byte, error) { var buf bytes.Buffer if err := encode(\u0026amp;buf, reflect.ValueOf(x)); err != nil { return nil, err } return buf.Bytes(), nil } func encode(buf *bytes.Buffer, v reflect.Value) error { switch v.Kind() { case reflect.Invalid: buf.WriteString(\u0026quot;null\u0026quot;) case reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64: fmt.Fprintf(buf, \u0026quot;%d\u0026quot;, v.Int()) case reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64, reflect.Uintptr: fmt.Fprintf(buf, \u0026quot;%d\u0026quot;, v.Uint()) case reflect.String: fmt.Fprintf(buf, \u0026quot;%q\u0026quot;, v.String()) case reflect.Bool: if v.Bool() { buf.WriteString(\u0026quot;true\u0026quot;) } else { buf.WriteString(\u0026quot;false\u0026quot;) } case reflect.Ptr: return encode(buf, v.Elem()) case reflect.Slice, reflect.Array: buf.WriteByte('[') for i := 0; i \u0026lt; v.Len(); i++ { if i \u0026gt; 0 { buf.WriteByte(' ') } if err := encode(buf, v.Index(i)); err != nil { return err } if i \u0026lt; v.Len()-1 { buf.WriteByte(',') } } buf.WriteByte(']') case reflect.Map: buf.WriteByte('{') for i, key := range v.MapKeys() { if i \u0026gt; 0 { buf.WriteByte(' ') } if err := encode(buf, key); err != nil { return err } buf.WriteString(\u0026quot;: \u0026quot;) if err := encode(buf, v.MapIndex(key)); err != nil { return err } if i \u0026lt; v.Len()-1 { buf.WriteByte(',') } } buf.WriteByte('}') case reflect.Struct: buf.WriteByte('{') for i := 0; i \u0026lt; v.NumField(); i++ { if i \u0026gt; 0 { buf.WriteByte(' ') } fmt.Fprintf(buf, \u0026quot;%q:\u0026quot;, v.Type().Field(i).Name) if err := encode(buf, v.Field(i)); err != nil { return err } if i \u0026lt; v.NumField()-1 { buf.WriteByte(',') } } buf.WriteByte('}') default: // complex, chan, interface, func fmt.Fprint(buf, \u0026quot;null\u0026quot;) } return nil } func TestJsonMarshal(t *testing.T) { type Movie struct { Title, Subtitle string Year int Color bool Actor map[string]string Oscars []string Sequel *string } strangelove := Movie{ Title: \u0026quot;Dr. Strangelove\u0026quot;, Subtitle: \u0026quot;How I Learned to Stop Worrying and Love the Bomb\u0026quot;, Year: 1964, Color: false, Actor: map[string]string{ \u0026quot;Dr. Strangelove\u0026quot;: \u0026quot;Peter Sellers\u0026quot;, \u0026quot;Grp. Capt. Lionel Mandrake\u0026quot;: \u0026quot;Peter Sellers\u0026quot;, \u0026quot;Pres. Merkin Muffley\u0026quot;: \u0026quot;Peter Sellers\u0026quot;, \u0026quot;Gen. Buck Turgidson\u0026quot;: \u0026quot;George C. Scott\u0026quot;, \u0026quot;Brig. Gen. Jack D. Ripper\u0026quot;: \u0026quot;Sterling Hayden\u0026quot;, `Maj. T.J. \u0026quot;King\u0026quot; Kong`: \u0026quot;Slim Pickens\u0026quot;, }, Oscars: []string{ \u0026quot;Best Actor (Nomin.)\u0026quot;, \u0026quot;Best Adapted Screenplay (Nomin.)\u0026quot;, \u0026quot;Best Director (Nomin.)\u0026quot;, \u0026quot;Best Picture (Nomin.)\u0026quot;, }, } encodeBytes, err := Marshal(strangelove) if err != nil { t.Fatal(err.Error()) } else { t.Log(string(encodeBytes)) } var got Movie if err := json.Unmarshal(encodeBytes, \u0026amp;got); err != nil { t.Fatal(err.Error()) } if !reflect.DeepEqual(got, strangelove) { t.Error(\u0026quot;jsonUnmarshal faild!!!\u0026quot;) } else { t.Logf(\u0026quot;%v\u0026quot;, got) } }  修改reflect.Value 的值 在go中是可以通过反射来修改当前变量的值的，前提是当前reflect.Value 是可以寻址的。\n首先，先确定reflect.Value 中addressable 和变量类型的addressable 是有点差别的。 下面是reflect.Value 中可寻址的变量：\n slice 的元素 可寻址数组的元素 可寻址struct 的字段 指针引用的结果  x := 2 a := reflect.ValueOf(2) b := reflect.ValueOf(x) c := reflect.ValueOf(\u0026amp;x) d := x.Elem()  查看当前每个接受的Value 是否能够取得地址\nfmt.Println(a.CanAddr()) // false fmt.Println(b.CanAddr()) // false fmt.Println(c.CanAddr()) // false fmt.Println(d.CanAddr()) // true  可以看出每当我们通过指针间接地获取的reflect.Value 都是可取地址的，即使开始的是一个不可取地址的Value。比如，slice 的索引表达式e[i]将隐式地包含一个指针，它是可取地址的，即使开始的e表达式不支持也没有关系。则reflect.ValueOf(e).Index(i)对于的值也是可取地址的，即使原始的reflect.ValueOf(e) 不支持也没有关系。\n一般可以使用reflect.Value(\u0026amp;v).Elem() 获取一个可寻址对象。\nx := 2 addr := reflect.Value(\u0026amp;x).Elem() // 获取可寻址对象 addr.CanAddr() // true addr.Set(reflect.ValueOf(3)) // x 3 addr.SetInt(4)  ","id":1,"section":"posts","summary":"reflect.Type 和 reflect.Value 反射是由reflect包提供支持，它定义了俩个重要的类型，Type和Value。 一个Type表示一个Go类型，它是一个接口。refle","tags":["reflect","go"],"title":"reflect.Type 和 reflect.Value","uri":"https://nattygui.github.io/2020/10/typeandvalue/","year":"2020"},{"content":"centos7 中常用的查询命令 ps 显示当前进程信息  ps -A 显示所有的进程信息  PID TTY TIME CMD\r1 ? 00:00:08 systemd\r2 ? 00:00:00 kthreadd\r4 ? 00:00:00 kworker/0:0H\r6 ? 00:00:00 ksoftirqd/0\r7 ? 00:00:00 migration/0\r8 ? 00:00:00 rcu_bh\r9 ? 00:00:25 rcu_sched\r10 ? 00:00:00 lru-add-drain\r11 ? 00:00:00 watchdog/0\r12 ? 00:00:01 watchdog/1\r13 ? 00:00:00 migration/1\r14 ? 00:00:00 ksoftirqd/1\r16 ? 00:00:00 kworker/1:0H\r......\r ps -aux 显示所有包含其他使用者的行程  USER PID %CPU %MEM VSZ RSS TTY STAT START TIME COMMAND\rroot 1 0.0 0.1 125696 4264 ? Ss 04:55 0:08 /usr/lib/systemd/systemd --switched-root --system --deserialize 22\rroot 2 0.0 0.0 0 0 ? S 04:55 0:00 [kthreadd]\rroot 4 0.0 0.0 0 0 ? S\u0026lt; 04:55 0:00 [kworker/0:0H]\rroot 6 0.0 0.0 0 0 ? S 04:55 0:00 [ksoftirqd/0]\rroot 7 0.0 0.0 0 0 ? S 04:55 0:00 [migration/0]\rroot 8 0.0 0.0 0 0 ? S 04:55 0:00 [rcu_bh]\rroot 9 0.0 0.0 0 0 ? S 04:55 0:25 [rcu_sched]\rroot 10 0.0 0.0 0 0 ? S\u0026lt; 04:55 0:00 [lru-add-drain]\r  ps -ef 显示所有进程信息，连同命令行\n  ps -u [用户名] 查询指定用户名的所有进程\n  netstat 查询网络信息 常用参数：\n-a (all)显示所有选项，默认不显示LISTEN相关\n-t (tcp)仅显示tcp相关选项\n-u (udp)仅显示udp相关选项\n-n 拒绝显示别名，能显示数字的全部转化成数字。\n-l 仅列出有在 Listen (监听) 的服务状态\n-p 显示建立相关链接的程序名\nnetstat 查询所有的网络状态 netstat -a\r 一般使用的话 # 查询相应的处于监听状态的tcp netstat -alnt # 查询指定的端口号\rnetstat -alnt | grep 8080\r# 加上 p 查询到相应的 进程\rnetstat -alntp | grep 8080\r ","id":2,"section":"posts","summary":"centos7 中常用的查询命令 ps 显示当前进程信息 ps -A 显示所有的进程信息 PID TTY TIME CMD 1 ? 00:00:08 systemd 2 ? 00:00:00 kthreadd 4 ? 00:00:00 kworker/0:0H 6 ? 00:00:00 ksoftirqd/0 7 ? 00:00:00 migration/0 8 ? 00:00:00 rcu_bh 9 ? 00:00:25 rcu_sched 10 ? 00:00:00 lru-add-drain 11 ? 00:00:00 watchdog/0 12","tags":["centos7"],"title":"centos7 中常用的查询命令","uri":"https://nattygui.github.io/2020/09/querycommand/","year":"2020"},{"content":"Centos7 安装redis 1、 检查是否有redis yum 源 若没有执行下一步，若有执行第三步\nyum search redis\ryum info redis\r 2、安装 epel 仓库 yum install -y epel-release  3、 安装redis 数据库 yum info redis\ryum install -y redis\r 4、 启动redis服务 systemctl start redis\rsystemctl enable redis # 设置开机启动\r 5、进入 redis 客户端 [admin@localhost ~]$ redis-cli\r127.0.0.1:6379\u0026gt;  ","id":3,"section":"posts","summary":"Centos7 安装redis 1、 检查是否有redis yum 源 若没有执行下一步，若有执行第三步 yum search redis yum info redis 2、安装 epel 仓库 yum install -y epel-release 3、 安装redis 数据库 yum info redis","tags":["centos7"],"title":"Centos7 安装redis","uri":"https://nattygui.github.io/2020/09/installredis/","year":"2020"},{"content":"Centos7 下traojan配置privoxy 下载trojan 首先去github下载 linux版本 https://github.com/trojan-gfw/trojan/releases/tag/v1.16.0\nwget https://github.com/trojan-gfw/trojan/releases/download/v1.16.0/trojan-1.16.0-linux-amd64.tar.xz tar xvf trojan-1.16.0-linux-amd64.tar.xz  将配置写在config.json下\ncd trojan // 写入配置 vi config.json // 后台运行trojan nohup ./trojan \u0026amp;  下载与配置privoxy 安装 wget https://download-ib01.fedoraproject.org/pub/epel/7/x86_64/Packages/p/privoxy-3.0.26-1.el7.x86_64.rpm rpm -Uvh privoxy-3.0.26-1.el7.x86_64.rpm  配置 vi /etc/privoxy/config  写入以下内容\nlisten-address 127.0.0.1:1081 toggle 0 show-on-task-bar 0 activity-animation 0 forward-socks5 / 127.0.0.1:1080 . hide-console  启动服务 先关闭selinux, 不然可能没法启用privoxy\n//1. 临时关闭 setenforce 0 // 2. 永久关闭 (需要reboot才能生效) vi /etc/selinux/config // 找到对应行，设置disabled SELINUX=disabled // 重新启动, 若设置永久关闭需要重新启动trojan reboot  启动代理\nsystemctl start privoxy.service  设置全局代理 export http_proxy=http://localhost:1081/ export https_proxy=http://localhost:1081/  ping [root@localhost Downloads]# ping google.com PING google.com (172.217.25.14) 56(84) bytes of data. 64 bytes from hkg07s24-in-f14.1e100.net (172.217.25.14): icmp_seq=1 ttl=116 time=23.2 ms 64 bytes from hkg07s24-in-f14.1e100.net (172.217.25.14): icmp_seq=2 ttl=116 time=23.6 ms 64 bytes from hkg07s24-in-f14.1e100.net (172.217.25.14): icmp_seq=3 ttl=116 time=23.6 ms 64 bytes from hkg07s24-in-f14.1e100.net (172.217.25.14): icmp_seq=4 ttl=116 time=23.9 ms 64 bytes from hkg07s24-in-f14.1e100.net (172.217.25.14): icmp_seq=5 ttl=116 time=23.3 ms  ","id":4,"section":"posts","summary":"Centos7 下traojan配置privoxy 下载trojan 首先去github下载 linux版本 https://github.com/trojan-gfw/trojan/releases/tag/v1.16.0 wget https://github.com/trojan-gfw/trojan/releases/download/v1.16.0/trojan-1.16.0-linux-amd64.tar.xz tar xvf trojan-1.16.0-linux-amd64.tar.xz 将配置写在config.json下 cd trojan //","tags":["centos7"],"title":"Privoxy","uri":"https://nattygui.github.io/2020/09/privoxy/","year":"2020"},{"content":"GMP模型 含义 Goroutine 的并发编程模型基于GMP模型，其中基本含义如下：\n  G: 表示goroutine，每个goroutine都有自己的栈空间，定时器，初始化的栈空间在2k左右，空间会随着需求增长。\n  M: 抽象化代表为内核线程，记录内核线程栈信息，当goroutine调度到线程时，使用该goroutine自己的栈信息。\n  P: 为一个逻辑Processor，代表调度器，负责调度goroutine，维护一个本地goroutine队列，M从P上获得goroutine并执行，同时还负责部分呢内存的管理。\n  模型 全局队列： 存放等待允许的G。 P的本地队列： 同全局队列类似，存放的也是等待运行的G，存的数量有限，不超过256个。新建一个G时，G优先加入到P的本地队列，如果队列满了，则会把本地队列中一半的G移动到全局队列 P列表：所有的P都在程序启动时创建，并保存在数组中，最多有GOMAXPROCS个P M：线程想运行任务就得获取P，从P的本地队列获取G，P队列为空的时候，M也会尝试从全局队列拿一批G放到P的本地队列，或从其他P的本地队列拿一半放到自己P的本地队列。M运行G，G执行之后，M会从P获取下一个G，不断重复下去。  M表示一个用户态线程，在M上有一个P和G，P是绑定到M上的，M获取G是通过P的调度获取的，在某一时刻，一个M上只有一个G（G0）除外。 在P上拥有一个G队列，里面是已经就绪的G，是可以被调度到线程栈上执行的协程，称为运行队列。\nP和M的个数问题 1、 P的数量\n由启动时环境变量$GOMAXPROCS 或者是由runtime 的方法GOMAXPROCS() 决定。这意味着在程序执行的任意时刻都只有$GOMAXPROCS 个Goroutine 在同时运行。\n2、 M的数量\n  go语言本身的限制：go程序启动时，会设置M的最大数量，默认为10000。但是内核很难支持这么多的线程数，所以这个限制可以忽略。\n  runtime/debug 中的SetMaxThreads函数，设置M的最大数量\n  一个M阻塞了，会创建新的M\n   M与P的数量没有绝对关系，一个M阻塞，P就会去创建或者切换另一个M，所以，即使P的默认数量为1，也有可能创建很多个M出来。\n 调度器的设计策略 复用线程 避免频繁的创建、销毁线程，而是对线程的复用\n  work steaking 机制： 当本线程无可运行的G时，尝试从其他线程绑定的P偷取G，而不是销毁线程。\n  hand off 机制：当本线程因为G进行系统调用阻塞时，线程释放绑定的P，把P转移给其他空闲的线程执行。\n  并行利用 GOMAXPROCS设置P的数量，最多有\u0008GOMAXPROCS个线程分布在多个CPU上同时运行。GOMAXPROCS也限制了并发的程度，比如GOMAXPROCS=核心数/2， 则最多利用一半的CPI核进行并行。\n抢占 在coroutine中要等待一个协程主动让出一个CPU才执行下一个协程，在Go中，一个goroutine最多占用CPU 10ms，防止其他goroutine饿死，这是goroutine 不同于别的coroutine的一个地方。\n全局G队列 在最新的go语言中，存在一个全局G队列，但功能被弱化了，当M执行work stealing从其他P偷不到G时，它可以从全局G队列获取G。\n","id":5,"section":"posts","summary":"GMP模型 含义 Goroutine 的并发编程模型基于GMP模型，其中基本含义如下： G: 表示goroutine，每个goroutine都有自己的栈空间，定时器，初","tags":["go"],"title":"GMP模型","uri":"https://nattygui.github.io/2020/06/gmp/","year":"2020"},{"content":"golang实现不分配额外内存[]byte和string转换 普通的强转 一般在进行[]byte 和string之间进行转换时，通过进行强转实现。这样进行强转的话，都会在额外的拷贝，从而造成额外的内存分配。\nstr := \u0026quot;test\u0026quot;\r// 转换为[]byte\rbytes := []byte(str)\r// 转换为str\rstr1 := string(bytes)\r 优化后 // 通过底层数据转换\rpackage strbytesconv\rimport (\r\u0026quot;reflect\u0026quot;\r\u0026quot;unsafe\u0026quot;\r)\r// StringToBytes 实现string 转换成 []byte, 不用额外的内存分配\rfunc StringToBytes(str string) (bytes []byte) {\rss := *(*reflect.StringHeader)(unsafe.Pointer(\u0026amp;str))\rbs := (*reflect.SliceHeader)(unsafe.Pointer(\u0026amp;bytes))\rbs.Data = ss.Data\rbs.Len = ss.Len\rbs.Cap = ss.Len\rreturn bytes\r}\r// BytesToString 实现 []byte 转换成 string, 不需要额外的内存分配\rfunc BytesToString(bytes []byte) string {\rreturn *(*string)(unsafe.Pointer(\u0026amp;bytes))\r}\r  StringHeader 是go中string 在底层的定义  type StringHeader struct {\rData uintptr\rLen int\r}\r  SliceHeader 是go中切片 在底层的定义  type SliceHeader struct {\rData uintptr\rLen int\rCap int\r}\r 上诉的优化方法通过将unsafe.Pointer获取地址，实现 SliceHeader 和 SliceHeader 之间的转换。\n测试 准确率测试-通过 func Test_StringToBytes(t *testing.T) {\rtype args struct {\rstr string\r}\rtests := []struct {\rname string\rargs args\rwantBytes []byte\r}{\r// TODO: Add test cases.\r{\rname: \u0026quot;testStrToBytes\u0026quot;,\rargs: args{\rstr: \u0026quot;abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\u0026quot;,\r},\rwantBytes: []byte(\u0026quot;abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\u0026quot;),\r},\r}\rfor _, tt := range tests {\rt.Run(tt.name, func(t *testing.T) {\rgotBytes := StringToBytes(tt.args.str)\rif !reflect.DeepEqual(gotBytes, tt.wantBytes) {\rt.Errorf(\u0026quot;StringToBytes() = %v, want %v\u0026quot;, gotBytes, tt.wantBytes)\r}\rt.Logf(\u0026quot;gotBytes Pointer %p, tt.args.str Pointer %p\u0026quot;, \u0026amp;gotBytes, \u0026amp;tt.args.str)\r})\r}\r}\r func Test_BytesToString(t *testing.T) {\rtype args struct {\rbytes []byte\r}\rtests := []struct {\rname string\rargs args\rwant string\r}{\r// TODO: Add test cases.\r{\rname: \u0026quot;testBytesToStr\u0026quot;,\rargs: args{\rbytes: []byte(\u0026quot;abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\u0026quot;),\r},\rwant: \u0026quot;abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\u0026quot;,\r},\r}\rfor _, tt := range tests {\rt.Run(tt.name, func(t *testing.T) {\rgot := BytesToString(tt.args.bytes)\rif got != tt.want {\rt.Errorf(\u0026quot;BytesToString() = %v, want %v\u0026quot;, got, tt.want)\r}\rt.Logf(\u0026quot;gotStr Pointer %p, tt.args.bytes Pointer %p\u0026quot;, \u0026amp;got, \u0026amp;tt.args.bytes)\r})\r}\r}\r 基准测试 var testStr = \u0026quot;abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\u0026quot;\rvar testBytes = []byte(testStr)\rfunc getBytesToString(bytes []byte) string {\rreturn string(bytes)\r}\rfunc getStringToBytes(str string) []byte {\rreturn []byte(str)\r}\rfunc Benchmark_StringToBytes(b *testing.B) {\rfor i := 0; i \u0026lt; b.N; i++ {\rStringToBytes(testStr)\r}\r}\rfunc Benchmark_getStringToBytes(b *testing.B) {\rfor i := 0; i \u0026lt; b.N; i++ {\rgetStringToBytes(testStr)\r}\r}\rfunc Benchmark_BytesToString(b *testing.B) {\rfor i := 0; i \u0026lt; b.N; i++ {\rBytesToString(testBytes)\r}\r}\rfunc Benchmark_getBytesToString(b *testing.B) {\rfor i := 0; i \u0026lt; b.N; i++ {\rgetBytesToString(testBytes)\r}\r}\r 结果 执行：\rgo test -v -run=none -bench=. -benchmem=true\rBenchmark_StringToBytes-8 1000000000 0.477 ns/op 0 B/op 0 allocs/op\rBenchmark_getStringToBytes-8 20491503 58.0 ns/op 64 B/op 1 allocs/op\rBenchmark_BytesToString-8 1000000000 0.473 ns/op 0 B/op 0 allocs/op\rBenchmark_getBytesToString-8 22655529 49.1 ns/op 64 B/op 1 allocs/op\r 可以看出，有明显的速度提升\n","id":6,"section":"posts","summary":"golang实现不分配额外内存[]byte和string转换 普通的强转 一般在进行[]byte 和string之间进行转换时，通过进行强转实现。","tags":["go"],"title":"golang实现不分配额外内存[]byte和string转换","uri":"https://nattygui.github.io/2020/06/strbytesconv/","year":"2020"},{"content":"Goroutines和Channels 并发程序指同时进行多个任务的程序，随着硬件的发展，并发程序变得越来越重要。web服务器会一次处理成千上万的请求。平板电脑和手机app在渲染用户画面同时还会后台执行各种计算任务和网络请求。即使是传统的批处理问题-读取数据，计算，写输出-现在也会用并发来隐藏掉I/O的操作延迟以充分利用现代计算机设备的多个核心。计算机的性能每年都在以非线性的速度增长。\ngolang中并发程序可以用俩种手段来实现，本章讲解goroutine和channe，其支持“顺序通信进程”（communicating sequential processes）或被简称为CSP。CSP是一种现代的并发编程模型，在这种编程模型中值会在不同的运行实例（goroutine）中传递，尽管大多数情况下任然是被限制在单一实例中。\nGoroutine goroutine和线程 goroutine和操作系统的线程区别可以忽略不记，俩者的区别实际上只是一个量上的区别，但是量变会引起质变的道理同样适用于goroutine和线程。\n动态栈 每一个OS线程都有一个固定大小的内存块（一般会是2MB）来做栈，这个栈会用来存储当前正在被调用或挂起（指在调用其它函数时）的函数的内部变量。\n而每一个goroutine会以一个很小的栈开始其生命周期，一般只需要2KB，一个goroutine的栈和操作系统线程一样，会保存其活跃或挂起的函数调用的本地变量。\n但是和OS线程不太一样的是一个goroutine的栈大小并不是固定的，栈的大小会根据需要动态地伸缩。而goroutine栈的最大值有1GB，比传统的固定大小的线程栈要大得多，尽管一般情况下，大多goroutine都不需要这么大得栈。\ngoroutine调度 OS线程会被操作系统内核调度，每几毫秒，一个硬件计时器会中断处理器，这会调用一个叫做scheduler的内核函数，这个函数会挂起当前执行的线程并保存内存中它的寄存器内容，并检查线程列表并决定下一次哪个线程可以被运行，并从内存中恢复该线程的寄存器信息，然后恢复执行该线程的现场并开始执行线程。因为操作系统线程是被内核所调度，所以从一个线程恢复执行该线程的现场并开始执行线程。\n因为操作系统线程是被内核所调度，所以从一个线程向另一个“移动”需要完整的上下文切换，也就是说保存一个用户线程的状态到内存，恢复另一个线程到寄存器，然后更新调度器的数据结构。这几步操作很慢，因为其局限性很差需要几次内存访问，并且会增加运行的cpu周期。\nGo的运行时包含了其自己的调度器，这个调度器使用了一些技术手段，比如m：n调度，因为其会在n个操作系统线程上多工调度m个goroutine。Go调度器的工作和内核的调度是相似的，但是这个调度器只会关注单独Go程序中的goroutine。\n和操作系统的线程调度不同的是，go调度器并不是用一个硬件定时器而是被go语言”建筑“本身进行调度的。例如当一个goroutine调用了time.Sleep或者被channel调用或者mutex操作阻塞时，调度器会使其进入休眠并开始执行另一个goroutine直到时机到了再去唤醒第一goroutine。因为这种调度方式不需要进入内核的上下文，所以重新调度一个goroutine比调度一个线程代价要低得多。\n并发版本的hello world 使用 sync.mutex 实现 func main() {\rvar mu sync.mutex\rmu.Lock()\rgo func() {\rfmt.Println(\u0026quot;hello world\u0026quot;)\rmu.Unlock()\r}()\rmu.Lock()\r}\r 在第二次执行Lock() 锁时，由于锁已经被占用所以main函数会阻塞，此时main函数的阻塞会驱使goroutine继续，当goroutine执行完毕时，一个锁会打开，第二锁会继续锁住，main函数会继续执行。\n使用无缓冲通道channel 实现 使用互斥锁是比较低级的做法，现在使用无缓冲的管道实现。\nfunc main() {\rdone := make(chan int)\rgo func() {\rfmt.Println(\u0026quot;hello world\u0026quot;)\r\u0026lt;- done }\rdone \u0026lt;- 1\r}\r// 调换位置也可以实现\r 上面中，在最后一条语句向done发送一条1，由于done是无缓冲的，所以它会一直等待done接收才会向下执行。\n根据go语言内存模型规范，对于无缓冲Channel进行的接收，发生在对该Channel进行的发送完成之前，因此，后台线程 \u0026lt;-done 接收操作完成之后， main线程的 done \u0026lt;- 1 发送操作才可能完成(从而退出main, 退出程序), 而此时打印工作已经完成了。\n使用有缓存的通道 上面无缓冲的通道虽然可以正常同步，但是对管道的缓存大小敏感，如果管道有缓存的话，就无法保证main退出之前后台线程能正常打印了。\n更好的做法是管道的发送和接收方向调换一下，这样可以避免同步事件受管道缓存大小的影像。\nfunc main() {\rdone := make(chan int, 1)\rgo func() {\rfmt.Println(\u0026quot;hello world\u0026quot;)\rdone \u0026lt;- 1\r}\r\u0026lt;-done\r}\r 对于带缓冲的Channel，对于Channel 的第K个接收完成操作发生在第K+C个发送操作完成之前，其中C是Channel的缓存太小，虽然管道是带缓存的，main 线程接收完成是在后台线程发送开始但还未完成的时刻，此时打印工作也是已经完成的。\nN个缓存的通道 基于带缓存的管道，我们可以很容易将打印线程扩展到N个。下面的例子是开启10个后台线程分别打印\nfunc main() {\rdone := make(chan int, 10) // 开N个后台打印缓存\rfor i := 0; i \u0026lt; cap(done); i++ {\rgo func() {\rfmt.Println(\u0026quot;hello world\u0026quot;)\rdone \u0026lt;- 1\r}()\r}\r// 等待N 个后台线程完成\rfor i := 0; i \u0026lt; cap(done); i++ {\r\u0026lt;- done\r}\r}\r 使用 sync.WaitGroup 来实现 func main() {\rvar wg sync.WaitGroup\r// 开N个后台打印线程\rfor i := 0; i \u0026lt; 10; i++ {\rwg.Add(1)\rgo func() {\rfmt.Println(\u0026quot;hello world\u0026quot;)\rwg.Done()\r}()\r// 等待N个后台线程完成\rwg.Wait()\r}\r}\r 其中 wg.Add(1) 用于增加等待事件的个数，必须确保在后台线程启动之前启动，当后台线程完成打印工作之后，调用 wg.Done() 表示完成一个事件。main 函数的wg.Wait() 是等待全部的事件完成。\n","id":7,"section":"posts","summary":"Goroutines和Channels 并发程序指同时进行多个任务的程序，随着硬件的发展，并发程序变得越来越重要。web服务器会一次处理成千上","tags":["go"],"title":"Goroutines和Channels","uri":"https://nattygui.github.io/2020/06/goroutines_and_channels/","year":"2020"},{"content":"golang 数据结构之map 介绍 map是hash table数据结构，它支持快速的查找、增加和删除。\n定义和声明 map[keyType]ValueType\r 其中 keyType 必须是可比较的数据类型 (golang官网说明)，比如 布尔类型（bool）、数值类型（int, uint, float等)、string、指针（pointer）、通道（channel）、接口（interface）或者包含以上基础类型的 struct、arrays。 但是不支持 切片（slices)、map、函数（function）。\nvalueType 支持任何数据类型\n这样定义一个map，maps的值为nil，必须重新进行赋值才能够访问，若直接进行访问，会导致runtime panic。\nvar maps map[int]int\r 建议通过make定义一个map，这样在创建的时候make会分配和初始化一个hash map数据结构。\nmaps := make(map[int]int)\r map的使用 map支持存在与不存在的key值进行访问，若key值存在返回，相应的value；若不存在返回valueType的零值\nmaps := make(map[int]int)\rmaps[1] = 2\rmaps[3] = 4\rs1 := maps[1] // s1 == 1\rs2 := maps[2] //s1 == 2\r 支持判断是否当前key值存在\ns3, ok := maps[3] // s3 == 4, ok == true\rs4, ok := maps[4] // s4 == 0, ok == false\r 遍历map 通过range函数来遍历map，支持俩种遍历方式, 且都是无序遍历的。\n 只获取key值  for k := range maps {\r// 使用k\r}\r 获取kv值  for k, v := range maps {\r// 使用 k，v\r}\r 有序的遍历map  import \u0026quot;sort\u0026quot;\rvar maps map[int]int\rvar keys []int\rfor k := range maps {\rkeys = append(keys, k)\r}\rsort.Ints(keys)\rfor _, k := range keys {\rfmt.Println(\u0026quot;Key:\u0026quot;, k, \u0026quot;Value:\u0026quot;, maps[k])\r}\r ","id":8,"section":"posts","summary":"golang 数据结构之map 介绍 map是hash table数据结构，它支持快速的查找、增加和删除。 定义和声明 map[keyType]ValueType 其中 keyType 必须是可比较的数据类型 (golan","tags":["go"],"title":"map 介绍","uri":"https://nattygui.github.io/2020/06/map/","year":"2020"},{"content":"Git 基本操作 查看工作状态和历史提交 进行仓库的初始化以及创建 git init 将文件添加到暂存区 git add 上传提交的名字 git commit -m \u0026quot;....\u0026quot; 查看状态 git status 将修改的文件从 暂存区中恢复 git checkout -- \\\u0026lt;file\u0026gt; 查看历史提交记录 git log 再次提交git  ","id":9,"section":"posts","summary":"Git 基本操作 查看工作状态和历史提交 进行仓库的初始化以及创建 git init 将文件添加到暂存区 git add 上传提交的名字 git commit -m \u0026quot;....\u0026quot; 查看状态 git status 将修改的文件从 暂存区中恢","tags":["git","github"],"title":"Git","uri":"https://nattygui.github.io/2019/10/git/","year":"2019"}],"tags":[{"title":"centos7","uri":"https://nattygui.github.io/tags/centos7/"},{"title":"git","uri":"https://nattygui.github.io/tags/git/"},{"title":"github","uri":"https://nattygui.github.io/tags/github/"},{"title":"go","uri":"https://nattygui.github.io/tags/go/"},{"title":"reflect","uri":"https://nattygui.github.io/tags/reflect/"}]}